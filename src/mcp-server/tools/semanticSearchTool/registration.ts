/**
 * @fileoverview Registers the Smart Connections semantic search tool with the MCP server.
 * The handler loads embeddings generated by Obsidian's Smart Connections plugin, encodes
 * the query with Xenova BGE models, and returns cosine-similarity ranked results.
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { promises as fs } from "fs";
import path from "path";
import { z } from "zod";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import type { VaultCacheService } from "../../../services/obsidianRestAPI/vaultCache/index.js";
import { config } from "../../../config/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  RequestContext,
  requestContextService,
} from "../../../utils/index.js";
import {
  cosine,
  SmartEnvCache,
  type SmartVec,
} from "../../../services/smartEnv.js";
import { getEmbedder } from "../../../adapters/embed/xenova.js";

type EmbedFunction = (text: string) => Promise<number[]>;

type SmartSearchResponse = {
  model?: string;
  dim?: number;
  results: Array<{
    path: string;
    score: number;
    title?: string;
    snippet?: string;
  }>;
};

const SmartSearchInputSchema = z.object({
  query: z
    .string({ required_error: "query is required" })
    .min(2, "query must contain at least two characters"),
  top_k: z
    .number()
    .int()
    .min(1)
    .max(100)
    .optional()
    .describe("Maximum number of results to return (default: 20)."),
  folders: z
    .array(z.string())
    .optional()
    .describe(
      "Optional list of folder prefixes (vault-relative) to restrict the search results.",
    ),
  tags: z
    .array(z.string())
    .optional()
    .describe("Optional list of tags to filter results."),
  with_snippets: z
    .boolean()
    .optional()
    .describe("Include up to 300 characters from each matching note (default: true)."),
});

type SmartSearchInput = z.infer<typeof SmartSearchInputSchema>;

const TOOL_NAMES = [
  {
    name: "smart_semantic_search",
    description:
      "Performs Smart Connections semantic search using local embeddings with cosine similarity.",
  },
  {
    name: "smart_search",
    description: "Alias of smart_semantic_search for backwards compatibility.",
  },
  {
    name: "smart-search",
    description: "Alias of smart_semantic_search for backwards compatibility.",
  },
] as const;

const smartEnvCacheRegistry = new Map<string, SmartEnvCache>();

const getVaultRoot = (): string | null => {
  if (config.obsidianVaultPath) {
    return config.obsidianVaultPath;
  }

  if (config.smartEnvDir) {
    return config.smartEnvDir.replace(/([/\\])\.smart-env.*/u, "");
  }

  return null;
};

const getSmartEnvCache = (): SmartEnvCache => {
  const directory = config.smartEnvDir ?? "";
  const cacheKey = directory || "__unset__";

  if (!smartEnvCacheRegistry.has(cacheKey)) {
    smartEnvCacheRegistry.set(
      cacheKey,
      new SmartEnvCache(directory, config.smartEnvCacheTtlMs ?? 60000),
    );
  }

  const cache = smartEnvCacheRegistry.get(cacheKey);
  if (!cache) {
    throw new McpError(
      BaseErrorCode.INTERNAL_ERROR,
      "SmartEnv cache initialisation failed",
    );
  }

  return cache;
};

let cachedEmbedder: { key: string; loader: Promise<EmbedFunction> } | null = null;

const SUPPORTED_VECTOR_DIMENSIONS = new Set([384, 768, 1024]);

const ensureConsistentVectorDimensions = (entries: SmartVec[]): number => {
  const dimensions = new Set<number>();

  for (const entry of entries) {
    const length = entry.vec.length;

    if (length <= 0) {
      throw new McpError(
        BaseErrorCode.INTERNAL_ERROR,
        `Invalid embedding data for '${entry.notePath}': vector is empty`,
      );
    }

    dimensions.add(length);
  }

  if (dimensions.size === 0) {
    throw new McpError(
      BaseErrorCode.INTERNAL_ERROR,
      "No embeddings available to determine vector dimension.",
    );
  }

  if (dimensions.size > 1) {
    throw new McpError(
      BaseErrorCode.CONFIGURATION_ERROR,
      `Smart Connections embeddings contain mixed vector dimensions (${[...
        dimensions
      ].join(", ")}). All embeddings must be regenerated using a single model.`,
    );
  }

  const [dimension] = [...dimensions];

  if (!SUPPORTED_VECTOR_DIMENSIONS.has(dimension)) {
    throw new McpError(
      BaseErrorCode.CONFIGURATION_ERROR,
      `Embedding dimension ${dimension} is not supported by the configured query embedder. ` +
        "Regenerate embeddings with a supported Xenova model (384, 768, or 1024).",
    );
  }

  return dimension;
};

const getQueryEmbedder = (dimension?: number): Promise<EmbedFunction> => {
  const embedderKind = (config.queryEmbedder ?? "xenova").toLowerCase();

  if (embedderKind !== "xenova") {
    throw new McpError(
      BaseErrorCode.CONFIGURATION_ERROR,
      `Unsupported QUERY_EMBEDDER value '${config.queryEmbedder}'. Only 'xenova' is implemented.`,
    );
  }

  const modelHint = config.queryEmbedderModelHint ?? undefined;
  const cacheKey = `${embedderKind}:${modelHint ?? ""}:${dimension ?? ""}`;

  if (!cachedEmbedder || cachedEmbedder.key !== cacheKey) {
    cachedEmbedder = {
      key: cacheKey,
      loader: getEmbedder(modelHint, dimension),
    };
  }

  return cachedEmbedder.loader;
};

const filterByFolders = (item: SmartVec, folders?: string[]): boolean => {
  if (!folders || folders.length === 0) {
    return true;
  }

  return folders.some((folder) => item.notePath.startsWith(folder));
};

const filterByTags = (item: SmartVec, tags?: string[]): boolean => {
  if (!tags || tags.length === 0) {
    return true;
  }

  const itemTags = item.tags ?? [];
  return itemTags.some((tag) => tags.includes(tag));
};

const readSnippet = async (
  vaultRoot: string | null,
  notePath: string,
): Promise<string | undefined> => {
  if (!vaultRoot) {
    return undefined;
  }

  const absolutePath = path.isAbsolute(notePath)
    ? notePath
    : path.join(vaultRoot, notePath);

  try {
    const content = await fs.readFile(absolutePath, "utf-8");
    return content.slice(0, 300);
  } catch (error) {
    logger.debug(
      `Unable to read snippet for ${notePath}: ${
        error instanceof Error ? error.message : String(error)
      }`,
    );
    return undefined;
  }
};

const performSmartSearch = async (
  params: SmartSearchInput,
): Promise<SmartSearchResponse> => {
  if (!config.smartEnvDir) {
    throw new McpError(
      BaseErrorCode.CONFIGURATION_ERROR,
      "SMART_ENV_DIR must be configured to use semantic search.",
    );
  }

  if (!config.enableQueryEmbedding) {
    throw new McpError(
      BaseErrorCode.CONFIGURATION_ERROR,
      "ENABLE_QUERY_EMBEDDING is disabled; semantic search cannot run.",
    );
  }

  const cache = getSmartEnvCache();
  const entries = await cache.getVectors();

  if (!entries.length) {
    throw new McpError(
      BaseErrorCode.INTERNAL_ERROR,
      `No embeddings available in ${config.smartEnvDir}`,
    );
  }

  const topK = params.top_k ?? 20;
  const includeSnippets = params.with_snippets ?? true;
  const vaultRoot = includeSnippets ? getVaultRoot() : null;

  const dimension = ensureConsistentVectorDimensions(entries);
  const model = entries[0]?.model;
  const embed = await getQueryEmbedder(dimension);
  const queryVector = await embed(params.query);

  if (queryVector.length !== dimension) {
    throw new McpError(
      BaseErrorCode.INTERNAL_ERROR,
      `Query embedder returned ${queryVector.length}-dimensional vectors but Smart Connections data uses ${dimension}.`,
    );
  }

  const filtered = entries.filter(
    (entry) =>
      filterByFolders(entry, params.folders) &&
      filterByTags(entry, params.tags),
  );

  const ranked = filtered
    .map((entry) => ({
      entry,
      score: cosine(queryVector, entry.vec),
    }))
    .sort((a, b) => b.score - a.score)
    .slice(0, topK);

  const results: SmartSearchResponse["results"] = [];

  for (const { entry, score } of ranked) {
    const snippet = includeSnippets
      ? await readSnippet(vaultRoot, entry.notePath)
      : undefined;

    results.push({
      path: entry.notePath,
      score,
      title: entry.title,
      snippet,
    });
  }

  return {
    model,
    dim: dimension,
    results,
  };
};

const registerSingleTool = (
  server: McpServer,
  toolName: string,
  toolDescription: string,
  registrationContext: RequestContext,
) => {
  server.tool(
    toolName,
    toolDescription,
    SmartSearchInputSchema.shape,
    async (params: SmartSearchInput) => {
      const handlerContext = requestContextService.createRequestContext({
        parentContext: registrationContext,
        operation: "HandleSmartSemanticSearchRequest",
        toolName,
        params,
      });

      logger.debug(`Handling '${toolName}' request`, handlerContext);

      return ErrorHandler.tryCatch(
        async () => {
          const response = await performSmartSearch(params);

          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(response, null, 2),
              },
            ],
            isError: false,
          };
        },
        {
          operation: `processing ${toolName} handler`,
          context: handlerContext,
          input: params,
          errorMapper: (error: unknown) =>
            new McpError(
              error instanceof McpError
                ? error.code
                : BaseErrorCode.INTERNAL_ERROR,
              `Error processing ${toolName}: ${
                error instanceof Error ? error.message : "Unknown error"
              }`,
              { ...handlerContext },
            ),
        },
      );
    },
  );
};

export const registerSemanticSearchTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
  vaultCacheService: VaultCacheService | undefined,
): Promise<void> => {
  void obsidianService;
  void vaultCacheService;

  const registrationContext = requestContextService.createRequestContext({
    operation: "RegisterSemanticSearchTool",
    module: "SemanticSearchRegistration",
    toolName: TOOL_NAMES[0]?.name ?? "smart_semantic_search",
  });

  logger.info(
    `Attempting to register tools: ${TOOL_NAMES.map(({ name }) => name).join(", ")}`,
    registrationContext,
  );

  await ErrorHandler.tryCatch(
    async () => {
      for (const { name, description } of TOOL_NAMES) {
        registerSingleTool(server, name, description, registrationContext);
        logger.info(`Tool registered successfully: ${name}`, registrationContext);
      }
    },
    {
      operation: "registering semantic search tools",
      context: registrationContext,
      errorCode: BaseErrorCode.INTERNAL_ERROR,
      errorMapper: (error: unknown) =>
        new McpError(
          error instanceof McpError ? error.code : BaseErrorCode.INTERNAL_ERROR,
          `Failed to register semantic search tools: ${
            error instanceof Error ? error.message : "Unknown error"
          }`,
          { ...registrationContext },
        ),
      critical: true,
    },
  );
};

